package main

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	ContextPackage = protogen.GoImportPath("context")
	CorePackage    = protogen.GoImportPath("github.com/chronos-tachyon/vsrpc")
	AssertPackage  = protogen.GoImportPath("github.com/chronos-tachyon/assert")
	ProtoPackage   = protogen.GoImportPath("google.golang.org/protobuf/proto")
	AnyPackage     = protogen.GoImportPath("google.golang.org/protobuf/types/known/anypb")
	EmptyPackage   = protogen.GoImportPath("google.golang.org/protobuf/types/known/emptypb")

	AnyType = protoreflect.FullName("google.protobuf.Any")

	EmptyType = protoreflect.FullName("google.protobuf.Empty")

	FileDescriptorProto_Package_FieldNumber = 2
	FileDescriptorProto_Syntax_FieldNumber  = 12

	DeprecationComment = "// Deprecated: Do not use."
)

var (
	AnyIdent   = AnyPackage.Ident("Any")
	EmptyIdent = EmptyPackage.Ident("Empty")
)

type void struct{}

type Generator struct {
	Plugin    *protogen.Plugin
	File      *protogen.File
	Out       *protogen.GeneratedFile
	MethodMap map[*protogen.Method]MethodProperties
}

func (g *Generator) Error(err error) {
	g.Plugin.Error(err)
}

func (g *Generator) P(v ...any) {
	g.Out.P(v...)
}

func (g *Generator) GenerateFile() {
	if len(g.File.Services) <= 0 {
		return
	}

	if g.MethodMap == nil {
		g.MethodMap = make(map[*protogen.Method]MethodProperties, 64)
	} else {
		for method := range g.MethodMap {
			delete(g.MethodMap, method)
		}
	}

	for _, service := range g.File.Services {
		for _, method := range service.Methods {
			var mp MethodProperties
			mp.Set(service, method)
			g.MethodMap[method] = mp
		}
	}

	fileName := g.File.GeneratedFilenamePrefix + "_vsrpc.pb.go"
	g.Out = g.Plugin.NewGeneratedFile(fileName, g.File.GoImportPath)
	g.GenerateLeadingComments(g.File.Desc.SourceLocations().ByPath(protoreflect.SourcePath{FileDescriptorProto_Package_FieldNumber}))
	g.P("// Code generated by protoc-gen-go-vsrpc. DO NOT EDIT.")
	g.P("// Versions:")
	g.P("// - protoc-gen-go-vsrpc: ", Version)
	g.P("// - protoc: ", g.ProtocVersion())
	g.P("// Source: ", g.File.Desc.Path())
	if g.File.Proto.GetOptions().GetDeprecated() {
		g.P("// Warning: the source file is deprecated.")
	}

	g.P()
	g.GenerateLeadingComments(g.File.Desc.SourceLocations().ByPath(protoreflect.SourcePath{FileDescriptorProto_Syntax_FieldNumber}))
	g.P("package ", g.File.GoPackageName)

	for _, service := range g.File.Services {
		g.GenerateCommon(service)
		g.GenerateClientInterface(service)
		g.GenerateClientImpl(service)
		g.GenerateServerInterface(service)
		g.GenerateHandlerImpl(service)
	}
}

func (g *Generator) ProtocVersion() string {
	v := g.Plugin.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}

	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func (g *Generator) GenerateLeadingComments(loc protoreflect.SourceLocation) {
	for _, s := range loc.LeadingDetachedComments {
		g.P(protogen.Comments(s))
		g.P()
	}
	if s := loc.LeadingComments; s != "" {
		g.P(protogen.Comments(s))
		g.P()
	}
}

func (g *Generator) GenerateCommon(service *protogen.Service) {
	if len(service.Methods) <= 0 {
		return
	}

	g.P()
	g.P("const (")
	for _, method := range service.Methods {
		mp := g.MethodMap[method]
		g.P("\t", mp.NameSymbol, " ", CorePackage.Ident("Method"), ` = "`, mp.NameValue, `"`)
	}
	g.P(")")
}

func (g *Generator) ClientInterfaceName(service *protogen.Service) string {
	return service.GoName + "Client"
}

func (g *Generator) ClientImplName(service *protogen.Service) string {
	return "vsrpcClientImpl_" + service.GoName
}

func (g *Generator) GenerateClientInterface(service *protogen.Service) {
	v := make([]any, 0, 16)
	interfaceName := g.ClientInterfaceName(service)

	g.P()
	g.P("// ", interfaceName, " is the client API for ", service.GoName, " service.")
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(DeprecationComment)
	}
	g.P("type ", interfaceName, " interface {")
	for _, method := range service.Methods {
		mp := g.MethodMap[method]

		v = v[:0]
		v = append(v, "\t", method.GoName)
		v = mp.AppendClientSignature(v)
		g.P(v...)
	}
	g.P("}")
}

func (g *Generator) GenerateClientImpl(service *protogen.Service) {
	interfaceName := g.ClientInterfaceName(service)
	implName := g.ClientImplName(service)

	g.P()
	g.P("func New", interfaceName, "(conn *", CorePackage.Ident("Conn"), ") ", interfaceName, " {")
	g.P("\treturn ", implName, "{conn: conn}")
	g.P("}")

	g.P()
	g.P("type ", implName, " struct {")
	g.P("\tconn *", CorePackage.Ident("Conn"))
	g.P("}")

	g.P()
	g.P("func (client ", implName, ") Conn() *", CorePackage.Ident("Conn"), " {")
	g.P("\treturn client.conn")
	g.P("}")

	for _, method := range service.Methods {
		g.GenerateClientMethod(service, method, implName)
	}

	g.P()
	g.P("var _ ", interfaceName, " = (*", implName, ")(nil)")
}

func (g *Generator) GenerateClientMethod(service *protogen.Service, method *protogen.Method, implName string) {
	mp := g.MethodMap[method]

	g.P()
	v := make([]any, 0, 16)
	v = append(v, "func (client ", implName, ") ", method.GoName)
	v = mp.AppendClientSignature(v)
	v = append(v, " {")
	g.P(v...)

	if mp.Out.IsSingular {
		g.P("\t", AssertPackage.Ident("NotNil"), "(&resp)")
		g.P("\tresp.Reset()")
		g.P()
	}

	g.P("\tcall, err := client.Conn().Begin(ctx, ", mp.NameSymbol, ", options...)")
	g.P("\tif err != nil {")
	g.P("\t\treturn err")
	g.P("\t}")
	g.P("\tdefer func() { _ = call.Close() }()")
	g.P()
	g.P("\tstream := ", CorePackage.Ident("NewBiStream"), "[*", mp.In.GoIdent, ", *", mp.Out.GoIdent, "](call)")

	if mp.In.IsSingular {
		g.P("err = stream.Send(req)")
		g.P("\tif err != nil {")
		g.P("\t\treturn err")
		g.P("\t}")
	}

	if !mp.In.IsPlural {
		g.P("\terr = stream.CloseSend()")
		g.P("\tif err != nil {")
		g.P("\t\treturn err")
		g.P("\t}")
	}

	if mp.In.IsPlural || mp.Out.IsPlural {
		g.P("\terr = fn(stream)")
		g.P("\tif err != nil {")
		g.P("\t\treturn err")
		g.P("\t}")
	}

	if mp.In.IsPlural {
		g.P("\terr = stream.CloseSend()")
		g.P("\tif err != nil {")
		g.P("\t\treturn err")
		g.P("\t}")
	}

	if mp.Out.IsSingular {
		g.P("\t_, _, err = stream.Recv(true, resp)")
		g.P("\tif err != nil {")
		g.P("\t\treturn err")
		g.P("\t}")
	}

	g.P("\treturn call.Wait().AsError()")
	g.P("}")
}

func (g *Generator) ServerInterfaceName(service *protogen.Service) string {
	return service.GoName + "Server"
}

func (g *Generator) HandlerImplName(service *protogen.Service) string {
	return "vsrpcHandler_" + service.GoName
}

func (g *Generator) GenerateServerInterface(service *protogen.Service) {
	v := make([]any, 0, 16)
	serverName := g.ServerInterfaceName(service)

	g.P()
	g.P("// ", serverName, " is the server API for ", service.GoName, " service.")
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(DeprecationComment)
	}
	g.P("type ", serverName, " interface {")
	for _, method := range service.Methods {
		mp := g.MethodMap[method]

		v = v[:0]
		v = append(v, "\t")
		v = append(v, method.GoName)
		v = mp.AppendServerSignature(v)
		g.P(v...)
	}
	g.P("}")
}

func (g *Generator) GenerateHandlerImpl(service *protogen.Service) {
	serverName := g.ServerInterfaceName(service)
	handlerName := g.HandlerImplName(service)

	g.P()
	g.P("func New", service.GoName, "Handler(impl ", serverName, ") ", CorePackage.Ident("Handler"), " {")
	g.P("\treturn ", handlerName, "{impl: impl}")
	g.P("}")
	g.P()
	g.P("type ", handlerName, " struct {")
	g.P("\timpl ", serverName)
	g.P("}")
	g.P()
	g.P("func (h ", handlerName, ") Handle(call *", CorePackage.Ident("Call"), ") error {")
	g.P("\tctx := call.Context()")
	g.P("\tmethod := call.Method()")
	g.P()
	g.P("\tif h.impl == nil {")
	g.P("\t\treturn ", CorePackage.Ident("NoSuchMethodError"), "{Method: method}")
	g.P("\t}")
	g.P()
	g.P("\tswitch method {")
	for _, method := range service.Methods {
		g.GenerateHandlerCase(service, method)
	}
	g.P("\tdefault:")
	g.P("\t\treturn ", CorePackage.Ident("NoSuchMethodError"), "{Method: method}")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()
	g.P("var _ ", CorePackage.Ident("Handler"), " = ", handlerName, "{}")
}

func (g *Generator) GenerateHandlerCase(service *protogen.Service, method *protogen.Method) {
	mp := g.MethodMap[method]
	v := make([]any, 0, 16)
	v = append(v, "\t\tif err := h.impl.", method.GoName, "(ctx")

	g.P("\tcase ", mp.NameSymbol, ":")
	if !mp.In.IsNullary || !mp.Out.IsNullary {
		g.P("\t\tstream := ", CorePackage.Ident("NewBiStream"), "[*", mp.Out.GoIdent, ", *", mp.In.GoIdent, "](call)")
	}
	if mp.In.IsSingular {
		g.P("\t\tvar req ", mp.In.GoIdent)
		g.P("\t\tif _, _, err := stream.Recv(true, &req); err != nil {")
		g.P("\t\t\treturn err")
		g.P("\t\t}")
		v = append(v, ", &req")
	}
	if mp.Out.IsSingular {
		g.P("\t\tvar resp ", mp.Out.GoIdent)
		v = append(v, ", &resp")
	}
	if mp.In.IsPlural || mp.Out.IsPlural {
		v = append(v, ", stream")
	}
	v = append(v, "); err != nil {")
	g.P(v...)
	g.P("\t\t\treturn err")
	g.P("\t\t}")
	if mp.Out.IsSingular {
		g.P("\t\tif err := stream.Send(&resp); err != nil {")
		g.P("\t\t\treturn err")
		g.P("\t\t}")
	}
	g.P()
}

type MethodProperties struct {
	Method     *protogen.Method
	NameSymbol string
	NameValue  string
	In         ParamProperties
	Out        ParamProperties
}

type ParamProperties struct {
	Message    *protogen.Message
	GoIdent    protogen.GoIdent
	IsPlural   bool
	IsSingular bool
	IsNullary  bool
}

func (mp *MethodProperties) Set(service *protogen.Service, method *protogen.Method) {
	inMessage := method.Input
	inIdent := inMessage.GoIdent
	inMulti := method.Desc.IsStreamingClient()
	inEmpty := (inIdent == EmptyIdent)

	outMessage := method.Output
	outIdent := outMessage.GoIdent
	outMulti := method.Desc.IsStreamingServer()
	outEmpty := (outIdent == EmptyIdent)

	*mp = MethodProperties{
		Method:     method,
		NameSymbol: fmt.Sprintf("vsrpcMethodName_%s_%s", service.GoName, method.GoName),
		NameValue:  fmt.Sprintf("%s.%s", service.Desc.FullName(), method.Desc.Name()),
		In: ParamProperties{
			Message:    inMessage,
			GoIdent:    inIdent,
			IsPlural:   inMulti,
			IsSingular: !inMulti && !inEmpty,
			IsNullary:  !inMulti && inEmpty,
		},
		Out: ParamProperties{
			Message:    outMessage,
			GoIdent:    outIdent,
			IsPlural:   outMulti,
			IsSingular: !outMulti && !outEmpty,
			IsNullary:  !outMulti && outEmpty,
		},
	}
}

func (mp MethodProperties) AppendClientSignature(out []any) []any {
	out = append(out, "(ctx ", ContextPackage.Ident("Context"))
	if mp.In.IsSingular {
		out = append(out, ", req *", mp.In.GoIdent)
	}
	if mp.Out.IsSingular {
		out = append(out, ", resp *", mp.Out.GoIdent)
	}
	switch {
	case mp.Out.IsPlural && mp.In.IsPlural:
		out = append(out, ", fn func(stream ", CorePackage.Ident("BiStream"), "[*", mp.In.GoIdent, ", *", mp.Out.GoIdent, "]) error")

	case mp.Out.IsPlural:
		out = append(out, ", fn func(stream ", CorePackage.Ident("RecvStream"), "[*", mp.Out.GoIdent, "]) error")

	case mp.In.IsPlural:
		out = append(out, ", fn func(stream ", CorePackage.Ident("SendStream"), "[*", mp.In.GoIdent, "]) error")
	}
	out = append(out, ", options ...", CorePackage.Ident("Option"), ") error")
	return out
}

func (mp MethodProperties) AppendServerSignature(out []any) []any {
	out = append(out, "(ctx ", ContextPackage.Ident("Context"))
	if mp.In.IsSingular {
		out = append(out, ", req *", mp.In.GoIdent)
	}
	if mp.Out.IsSingular {
		out = append(out, ", resp *", mp.Out.GoIdent)
	}
	switch {
	case mp.Out.IsPlural && mp.In.IsPlural:
		out = append(out, ", stream ", CorePackage.Ident("BiStream"), "[*", mp.Out.GoIdent, ", *", mp.In.GoIdent, "]")

	case mp.Out.IsPlural:
		out = append(out, ", stream ", CorePackage.Ident("SendStream"), "[*", mp.Out.GoIdent, "]")

	case mp.In.IsPlural:
		out = append(out, ", stream ", CorePackage.Ident("RecvStream"), "[*", mp.In.GoIdent, "]")
	}
	out = append(out, ") error")
	return out
}
