package main

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	Context = protogen.GoImportPath("context")
	Core    = protogen.GoImportPath("github.com/chronos-tachyon/vsrpc")

	EmptyMessage = protoreflect.FullName("google.protobuf.Empty")

	FileDescriptorProto_Package_FieldNumber = 2
	FileDescriptorProto_Syntax_FieldNumber  = 12

	DeprecationComment = "// Deprecated: Do not use."
)

type Generator struct {
	Plugin *protogen.Plugin
	File   *protogen.File
	Out    *protogen.GeneratedFile
}

func (g *Generator) Error(err error) {
	g.Plugin.Error(err)
}

func (g *Generator) P(v ...any) {
	g.Out.P(v...)
}

func (g *Generator) GenerateFile() {
	if len(g.File.Services) <= 0 {
		return
	}

	fileName := g.File.GeneratedFilenamePrefix + "_vsrpc.pb.go"
	g.Out = g.Plugin.NewGeneratedFile(fileName, g.File.GoImportPath)

	g.GenerateLeadingComments(g.File.Desc.SourceLocations().ByPath(protoreflect.SourcePath{FileDescriptorProto_Package_FieldNumber}))

	g.P("// Code generated by protoc-gen-go-vsrpc. DO NOT EDIT.")
	g.P("// Versions:")
	g.P("// - protoc-gen-go-vsrpc: ", Version)
	g.P("// - protoc: ", g.ProtocVersion())
	g.P("// Source: ", g.File.Desc.Path())
	if g.File.Proto.GetOptions().GetDeprecated() {
		g.P("// Warning: the source file is deprecated.")
	}
	g.P()

	g.GenerateLeadingComments(g.File.Desc.SourceLocations().ByPath(protoreflect.SourcePath{FileDescriptorProto_Syntax_FieldNumber}))

	g.P("package ", g.File.GoPackageName)

	for _, service := range g.File.Services {
		g.GenerateCommon(service)
		g.GenerateInterface(service)
		g.GenerateClientImpl(service)
		g.GenerateServerImpl(service)
	}
}

func (g *Generator) ProtocVersion() string {
	v := g.Plugin.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}

	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func (g *Generator) GenerateLeadingComments(loc protoreflect.SourceLocation) {
	for _, s := range loc.LeadingDetachedComments {
		g.P(protogen.Comments(s))
		g.P()
	}
	if s := loc.LeadingComments; s != "" {
		g.P(protogen.Comments(s))
		g.P()
	}
}

func (g *Generator) GenerateCommon(service *protogen.Service) {
	if len(service.Methods) <= 0 {
		return
	}

	g.P()
	g.P("const (")
	for _, method := range service.Methods {
		symbolName := fmt.Sprintf("vsrpcMethodName_%s_%s", service.GoName, method.GoName)
		symbolValue := fmt.Sprintf("%s.%s", service.Desc.FullName(), method.Desc.Name())
		g.P("\t", symbolName, ` = "`, symbolValue, `"`)
	}
	g.P(")")
}

func (g *Generator) GenerateInterface(service *protogen.Service) {
	typeName := service.GoName
	g.P()
	g.P("// ", typeName, " is the API for ", service.GoName, " service.")
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(DeprecationComment)
	}
	g.P("type ", typeName, " interface {")
	for _, method := range service.Methods {
		v := make([]any, 0, 16)
		v = append(v, "\t")
		v = append(v, method.GoName)
		v = AppendSignature(v, service, method)
		g.P(v...)
	}
	g.P("}")
}

func (g *Generator) GenerateClientImpl(service *protogen.Service) {
	typeName := "vsrpcClient_" + service.GoName
	g.P()
	g.P("type ", typeName, " struct {")
	g.P("\tcc *", Core.Ident("ClientConn"))
	g.P("}")
	g.P()
	g.P("var _ ", service.GoName, " = (*", typeName, ")(nil)")
}

func (g *Generator) GenerateServerImpl(service *protogen.Service) {
	typeName := "vsrpcHandler_" + service.GoName
	g.P()
	g.P("type ", typeName, " struct {")
	g.P("\timpl ", service.GoName)
	g.P("}")
	g.P()
	g.P("func (h *", typeName, ") Handle(call *", Core.Ident("ServerCall"), ") error {")
	g.P("\tmethod := call.Method()")
	g.P("\treturn ", Core.Ident("NoSuchMethodError"), "{Method: method}")
	g.P("}")
	g.P()
	g.P("var _ ", Core.Ident("Handler"), " = (*", typeName, ")(nil)")
}

func AppendSignature(out []any, service *protogen.Service, method *protogen.Method) []any {
	out = append(out, "(ctx ")
	out = append(out, Context.Ident("Context"))
	out = append(out, ") error")
	return out
}

type Cardinality byte

const (
	Nullary Cardinality = iota
	Singular
	Plural
)

func InputCardinality(service *protogen.Service, method *protogen.Method) Cardinality {
	if method.Desc.IsStreamingClient() {
		return Plural
	}
	if IsEmptyWKT(method.Input) {
		return Nullary
	}
	return Singular
}

func OutputCardinality(service *protogen.Service, method *protogen.Method) Cardinality {
	if method.Desc.IsStreamingServer() {
		return Plural
	}
	if IsEmptyWKT(method.Output) {
		return Nullary
	}
	return Singular
}

func IsEmptyWKT(message *protogen.Message) bool {
	return message.Desc.FullName() == EmptyMessage
}
